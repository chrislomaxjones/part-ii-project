\chapter{Implementation}

\section{High level structure of program}



\begin{figure}
\centering
\scalebox{.7}{
\setlength{\unitlength}{3947sp}%
%
\begingroup\makeatletter\ifx\SetFigFont\undefined%
\gdef\SetFigFont#1#2#3#4#5{%
  \reset@font\fontsize{#1}{#2pt}%
  \fontfamily{#3}\fontseries{#4}\fontshape{#5}%
  \selectfont}%
\fi\endgroup%
\begin{picture}(5277,3927)(3289,-9301)
\thinlines
{\color[rgb]{0,0,0}\put(4051,-8836){\framebox(3750,3450){}}
}%
{\color[rgb]{0,0,0}\put(5101,-7486){\vector(-1, 0){0}}
\put(5101,-7267){\oval(312,438)[br]}
\put(5026,-7267){\oval(462,462)[tr]}
\put(5026,-7267){\oval(462,462)[tl]}
\put(4951,-7267){\oval(312,438)[bl]}
}%
{\color[rgb]{0,0,0}\put(3301,-9211){\line( 1, 0){5100}}
}%
{\color[rgb]{0,0,0}\put(4201,-7861){\framebox(3300,1950){}}
}%
{\color[rgb]{0,0,0}\put(4501,-7561){\framebox(1200,1200){}}
}%
{\color[rgb]{0,0,0}\put(6001,-7561){\framebox(1200,1200){}}
}%
{\color[rgb]{0,0,0}\put(4201,-8611){\framebox(3300,450){}}
}%
{\color[rgb]{0,0,0}\put(6601,-7561){\vector( 0,-1){600}}
}%
{\color[rgb]{0,0,0}\put(4951,-7561){\vector( 0,-1){600}}
}%
{\color[rgb]{0,0,0}\put(5251,-8161){\vector( 0, 1){600}}
}%
{\color[rgb]{0,0,0}\put(6001,-9211){\vector( 0, 1){600}}
}%
{\color[rgb]{0,0,0}\put(5401,-8611){\vector( 0,-1){600}}
}%
\put(4651,-8461){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}Messaging subsystem}%
}}}}
\put(4501,-6211){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}Role module}%
}}}}
\put(4651,-6916){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}server}%
}}}}
\put(4651,-6661){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}Response}%
}}}}
\put(6151,-6661){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}Role}%
}}}}
\put(6151,-6886){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}specific}%
}}}}
\put(6151,-7111){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}systems}%
}}}}
\put(8551,-9286){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}Network}%
}}}}
{\color[rgb]{0,0,0}\put(6676,-7486){\vector(-1, 0){0}}
\put(6676,-7336){\oval(186,300)[br]}
\put(6601,-7336){\oval(336,336)[tr]}
\put(6601,-7336){\oval(336,336)[tl]}
\put(6526,-7336){\oval(186,300)[bl]}
}%
\put(4201,-5686){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}Process}%
}}}}
\end{picture}%

}
       \caption{High level subsystems of a process}
  \centering
\end{figure}





In this section the high level structure of the program is discussed. See figure {\color{red}blah blah} for an overview of the structure of a typical process. \\

Each of the processes takes the \emph{role} of either a client, replica, leader or acceptor. These roles each have a different function in the system within their \emph{role module}, which contains all the functionality associated specifically with a given role. \\

Each of the roles shares a number of common middlewares in the program, the main being the messaging subsystem. The purpose of this subsystem is to provide indirection between the way that messages are treated by the role modules and the method by which they are actually sent over the network. The desire is to have messages behave as an atomic primitive with semantics as described in {\color{red}Assumptions section}, obscuring all of the protocol-level functionality in sending the messages over an IP network. \\

The role module is divided up into two separate \texttt{Lwt} threads. The response server handles the receipt of messages from other processes and performs any required processing accordingly (this is still role specific), which can result in sending further messages. Any concurrent processing required of the role is performed concurrently in the role specific systems. \\

Each of the processes requires additional information at start-up, such as 

\begin{enumerate}
  \item The role it should take.
  \item The address at which it should start a server to receive messages.
  \item The set of addresses of all the participating processes of all roles.
\end{enumerate}

Items (1) and (2) are consumed via comand line arguments when the program is run. (3) requires the use of a configuration file, the relative path to which is provided as a command line argument. The configuration file is formatted in JSON and provides, for each role, a list of all of the addresses of each process. An example configuration file is included in {\color{red}Reference the appendix}. {\color{red}Figure blah blah shows a flow diagram describing how initialisation proceeds} \\

{\color{red}(Addresses are provided as an IP address (V4 or V6) and a port number)} \\

{\color{blue}Flow diagram of init}.


\section{Data structures}

Before proceeding the implementation of the systems described above, it is necessary to examine the data structures that will be used.

\subsection{Identifiers}

Unique identifiers are required to identify each process in the system. To avoid having a central authority distribute these identifiers at start-up a method where any process can generate their own unique identifer is used. Universally Unique Identifers\footnote{https://tools.ietf.org/html/rfc4122} (UUIDs) are used in this case as they are a well established standard and have support in the OCaml Core library. UUIDs are also totally ordered and so satisy the condition that we have such an ordering on the identifers of leaders. \\

Hence replicas, leaders and acceptor identifiers have the type \texttt{Core.Uuid.t}. As we wish to expose clients to a request / response protocol it is necessary to store a map of client identifiers to addresses by each replica. Rather, by modifying client identifiers to be of the form \texttt{Core.Uuid.t * Uri.t}, the address actually forms part of the identifier.

\subsection{Key value store}

\begin{figure}
  \begin{lstlisting}
module type APPLICATION = sig
  type state = (int, string) List.Assoc.t
  type operation = Nop                  
                 | Create of int * string  
                   ...          
  type result = Success 
              | Failure
                ...          
  val initial_state : state
  val apply : state -> operation -> state * result
   ...
end
  \end{lstlisting}
    \caption{Signature of the key value store module}
  \centering
\end{figure}


\begin{table}
  \centering
  \begin{tabular}{l | l | l}
    Command & Arguments & Semantics \\ \hline \hline
    Nop & & No operation, No change to state \\ [.5\normalbaselineskip] \hline
  
    Create & \texttt{(K,V)} & Add new \texttt{(K,V)} pair to the state \\
                 &        & If key already present, then return Failure \\ [.5\normalbaselineskip] \hline

  \end{tabular}
  \caption{Set of operations that can be applied to the application state, along with their corresponding arguments and their semantics. Note that Create and Update commands are separate, each with their own success and failure semantics in order to reduce ambiguity of how the application operates.}
\label{table:operation-summary}
\end{table}

The key value store is the application that is to be replicated. Hence each replica process will maintain its own independent copy of the application state. The application itself needs not maintain any synchronisation logic, it need only behave as a state machine. The state is represented by an association list (commonly called a dictionary) that maps integer keys to string values. Operations each have their own semantics described in Table \ref{table:operation-summary}. The application follows a state machine pattern given that if each replica starts in the initial state and each applies the same sequence of operations in the same order, the resulting state is the same. \\

When a command has been committed to a slot by the consensus algorithm, the command's operation is applied to the state. This returns a new state and a result, which represents the updated state held by the replica and the resulting information returned to the replica (the client does not receive a whole copy of the new state in its reply). {\color{red}The signature of this key value store is shown in figure blah blah}.

\subsection{Ballots}

The definition of ballot numbers from {\color{red} the Preparation chapter} lends itself to the types of ballot numbers being represented by an algebraic datatype. Ballots are hence the tagged union of Bottom (representing the least ballot $\bot$) or a pair consiting of an integer and a leader identifer (representing pairs $\left(n,\lambda\right)$). The type definition is included in {\color{red} Figure blah blah}. \\

\begin{figure}
  \begin{lstlisting}
type t = Bottom
       | Number of int * leader_id
  \end{lstlisting}
    \caption{Types of ballot numbers.}
  \centering
\end{figure}

Figure blah blah shows the interface exposed by the Ballot module. Note that the concrete type of ballot numbers isn't exposed, only the abstract type \texttt{t}. Therefore outside of this module the representation of ballot numbers is hidden. This prevents a large number of errors, such as decrementing a round number when they should strictly increase, from arising by rejecting them at compile-time. However, this requires a number of functions be supplied so that ballot numbers can be manipulated outside this module. \\

Hence a given leader can generate an initial ballot number with their identifer. Subsequent ballot numbers can be generated by calling a successor function, which increments the round number each time. By exposing such an interface we prevent errors such as using negative round numbers from being able to compile. \\

The module provides functions to test equality and the ordering of ballots. These work over the structure of ballots, comparing them first for correct types and then checking round number and leader id equality. Also in the Ballot module are functions for serialisation and deserialisation to and from JSON, required by the messaging system for sending ballots.

\begin{figure}
  \begin{lstlisting}
type t
val bottom : unit -> t
val init : leader_id -> t
val succ_exn : t -> t
  \end{lstlisting}
    \caption{The interface exposed by the Ballot module. These are the types of functions that can be used to generate ballot numbers. Note the naming of the function \texttt{succ\_exn} implies it can throw an exception, which occurs when calling the function on \texttt{bottom}.}
  \centering
\end{figure}

\section{Messages}

Start with a high level overview and goals of the messaging system. \\

Now talk about the different messages we can send. In this case show the datatypes. Draw distinctions between the blocking and non-blocking nature of the phase1/2 and other messages. Perhaps at this point show the interface we wish to expose to the above subsystem. This would include send\_non\_blocking, send\_blocking messages. This essentially should provide the semantics we desire. \\

\begin{figure}
  \begin{lstlisting}
type non_blocking_message = ClientRequestMessage of command
                          | ProposalMessage of proposal
                          | DecisionMessage of proposal
                          | ClientResponseMessage of command_id * result
                          
val send_request : non_blocking_message -> Uri.t -> unit Lwt.t

val send_phase1_message : Ballot.t -> Uri.t -> 
  (Core.Uuid.t * Ballot.t * Pval.t list, string) Result.result Lwt.t
    
val send_phase2_message : Pval.t -> Uri.t -> 
  (Core.Uuid.t * Ballot.t, string) Result.result Lwt.t
  \end{lstlisting}
  \centering
  \caption{Types of non-blocking messages}
\end{figure}

Talk about the interface exposed on behalf of the server

\begin{figure}
  \begin{lstlisting}
val start_new_server : ?request_callback:(Types.command -> unit) ->
    ?proposal_callback:(Types.proposal -> unit) ->
    ?response_callback:(Types.command_id * Types.result -> unit) ->
    ?phase1_callback:(Ballot.t -> Types.unique_id * Ballot.t * Pval.t list) ->
    ?phase2_callback:(Pval.t -> Types.unique_id * Ballot.t) ->
    string -> int -> Uri.t Lwt.t  
  \end{lstlisting}
  \centering
  \caption{Types of non-blocking messages}
\end{figure}

Now discuss Cap'n Proto. A quick overview of how it works. Discuss the schema file and how it corresponds to the messages we want to send. Talk about how compiling this produces ML interfaces and signatures we can use. Probably skim over the boilerplate code, just describe at a high-level how serialization works. \\

On the topic of serialization, talk about how things are serialized by their own respective methods. This can probably be quite a quick overview. \\

\begin{figure}
  \begin{lstlisting}
let send_request message uri =
  (* Get the service for the given URI *)
  service_from_uri uri >>= function
  | None -> Lwt.return_unit
  | Some service ->
    match message with
    | ClientRequestMessage cmd ->
      client_request_rpc service cmd;
    | DecisionMessage p ->
      decision_rpc service p;
    | ProposalMessage p ->
      proposal_rpc service p;
    | ClientResponseMessage (cid, result) ->
      client_response_rpc service cid result
  \end{lstlisting}
  \centering
  \caption{Types of non-blocking messages}
\end{figure}

Talk about addressing and the conversion we need. Then talk about a hash table that is used to cache the mapping from addresses to services. \\

\begin{figure}
  \begin{lstlisting}
let send_phase1_message (b : Ballot.t) uri = 
  service_from_uri uri >>= function 
  | None ->
    Lwt.return_error "Error sending phase 1 message"  
  | Some service -> 
    phase1_rpc service b >>= fun response ->
    Lwt.return_ok response
  \end{lstlisting}
  \centering
  \caption{Types of non-blocking messages}
\end{figure}

\begin{figure}
  \begin{lstlisting}
let service_from_uri uri =
  try Lwt.return_some (Hashtbl.find sturdy_refs uri)
  with Not_found ->
    let client_vat = Capnp_rpc_unix.client_only_vat () in
    let sr = Capnp_rpc_unix.Vat.import_exn client_vat uri in
      Sturdy_ref.connect sr >>= function
        | Ok capability ->
            Hashtbl.add sturdy_refs uri capability;
            Lwt.return_some capability
        | Error _ -> 
            Lwt.return_none
  \end{lstlisting}
  \centering
  \caption{Types of non-blocking messages}
\end{figure}

Next go on to talk about how we use Error types in the rpc responses to catch killed nodes and simply. Talk about how we need to refresh the cache in this case. Talk a bit more about the types used in phase1/phase2 messages as these may return Errors to the above subsystem. \\

{\color{red}Put a snippet here...?}

\section{Clients and replicas - better title?}

{\color{green}
\subsection{Clients}
\begin{itemize}
  \item Talk about how clients operate outside the system
  \item How they send messages to replicas.
  \item Include .mli interface for replicas, the record (with mutable fields) for storing replicas.
\end{itemize}
}

\subsection{Replicas}

Having discussed the functionality of clients it is necessary now to talk about the implementation of replicas. More introduction. \\

Replicas are required to implicitly take the role of learners in order to learn the decisions made on how to serialize the sequence of client requests. Rather than have the replicas explicity request the result of the synod protocol from the leaders or acceptors, acceptors forward the requests made by clients onto them and receive a response, implicitly learning the result.

Replicas maintain three queues: 
\begin{itemize}
  \item A queue of commands received in request messages from clients.
  \item A queue of proposals. These are commands that have been tagged with a provisional slot number. This queue forms the replica's own attempt at serializing the commands. However, these are not committed in this order until the configuration of leaders and acceptors has decided each command for that slot.
  \item A queue of decisions. This represents the serialization of commands that has been decided on by the synod protocol. The sequence of decided commands should be the same for each replicas.
\end{itemize}

The formulation of these data structures introduces the requirement for some program invariants, such as ... \\

\begin{figure}
  \begin{lstlisting}
let new_replica host port leader_uris =  
  let replica = initialize leader_uris in
    start_server replica host port >>=
    fun uri -> print_uri uri >>=
    fun () -> propose_lwt replica
  \end{lstlisting}
  \centering
  \caption{Snippet of startup of replica}
\end{figure}

\begin{figure}
\begin{lstlisting}
type t = {
  id : replica_id;
  mutable app_state : app_state;
  mutable slot_in : slot_number;
  mutable slot_out : slot_number;
  mutable requests : command list;
  mutable proposals : proposal list;
  mutable decisions : proposal list;
  mutable leaders : Uri.t list;
}
\end{lstlisting}
\centering
\caption{Types of records representing replica state. Note use of mutable keywords allowing for the records to be implicity modified withouth having to store and deal with record types.}
\end{figure}




\begin{itemize}
  \item Leading on from clients, explain how messages can be re-ordered / lost / delayed from clients and how broadcasts from replicas allow progress in the event of replica failure.
  \item Describe the two-fold operation of replicas. They receive and perform de-duplication of broadcast client messages. They then go on to propose to commit commands to given slots. They also handle when leaders reject their proposals so they can be re-proposed later. They also maintain the application state (in this case the replicated key-value store.)
  \item Interesting points to discuss include looking at a snippet of the de-duplication function and discussing it. Also looking at how mutexes are used to hold locks on the sets of commands, proposals, decisions etc.
  \item Include a diagram of the three different sets of commands, proposals and decisions and how each moves from one set to another in different sets of circumstances.
\end{itemize}

\section{Synod protocol}

\subsection{Quorums}
\begin{itemize}
  \item Describe how the quorum system was implemented. Show the .mli interface as a snippet and describe how this can be used to achieve majority quorums.
  \item Show briefly how the majority checking function was implemented.
\end{itemize}

\subsection{Acceptors}
\begin{itemize}
  \item Discuss the operation of acceptors - how they form the fault tolerant memory of Paxos.
  \item Discuss the functions (along with snippets) by which acceptors adopt and accept ballots.
\end{itemize}

\subsection{Leaders}
\begin{itemize}
  \item Describe how the operation of leaders is split into two sub-processes - scouts and commanders.
  \item Operational description of how scouts and commanders communicate concurrently. Diagram displaying how there is a message queue that these sub-processes use to send ``virtual'' messages.
  \item Snippets of the signatures and structs used to construct these sub-processes. 
\end{itemize}

\subsubsection{Scouts}
\begin{itemize}
  \item Describe how scouts secure ballots with acceptors. Relate this to operation of acceptors above.
  \item State how scouts enqueue virtual adopted messages after securing adoption from quorum of acceptors.
  \item Describe how pre-emption can occur when a commander is waiting for adoption.
\end{itemize}

\subsubsection{Commanders}
\begin{itemize}
  \item Explain how commanders attempt to commit their set of proposals.
  \item Give detail on the pmax and ``arrow'' function as used in the paper.
  \item Describe how pre-emption can occur when a commander is waiting for acceptance.
\end{itemize}

\section{Summary}
